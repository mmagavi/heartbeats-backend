export declare type RoutesType = {
    [name: string]: {
        path: string;
        params?: {
            [paramName: string]: true;
        };
        search?: {
            [paramName: string]: boolean;
        };
    };
};
export declare type RoutesReturn<R extends RoutesType> = {
    [K in keyof R]: (params?: {
        params?: {
            [PK in keyof R[K]['params']]: string | number;
        };
        search?: {
            [PK in keyof R[K]['search']]?: string | number;
        };
    }) => string;
};
export declare type UseNavigateReturn<R extends RoutesType> = {
    [K in keyof RoutesReturn<R>]: (params?: Parameters<RoutesReturn<R>[K]>[0]) => void;
};
export interface MakeRouteMapOptions {
    /**
     * By default, we match path parameters using the `:id` pattern.
     * You can change this by passing an alternative regex from
     * the result of this function.
     */
    paramMatcher?: (paramName: string) => RegExp;
}
/**
 * Use this function to create a single source of truth
 * for all routes in your app
 */
export declare const makeRouteMap: <R extends RoutesType>(routes: R, options?: MakeRouteMapOptions | undefined) => RoutesReturn<R>;
/**
 * Creates a navigate function which you can use to
 * navigate type-safely between all routes in your app
 */
export declare const makeNavigate: <R extends RoutesType>(routeMap: RoutesReturn<R>, goToRoute: (route: string) => void) => UseNavigateReturn<R>;
export default makeRouteMap;
