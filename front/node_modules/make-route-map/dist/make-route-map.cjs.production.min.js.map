{"version":3,"file":"make-route-map.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["export type RoutesType = {\n  [name: string]: {\n    path: string;\n    // Params contained in this path's URL\n    params?: {\n      [paramName: string]: true;\n    };\n    search?: {\n      // Is this field required or not?\n      [paramName: string]: boolean;\n    };\n  };\n};\n\nexport type RoutesReturn<R extends RoutesType> = {\n  [K in keyof R]: (params?: {\n    params?: { [PK in keyof R[K]['params']]: string | number };\n    search?: { [PK in keyof R[K]['search']]?: string | number };\n  }) => string;\n};\n\nexport type UseNavigateReturn<R extends RoutesType> = {\n  [K in keyof RoutesReturn<R>]: (\n    params?: Parameters<RoutesReturn<R>[K]>[0]\n  ) => void;\n};\n\nexport interface MakeRouteMapOptions {\n  /**\n   * By default, we match path parameters using the `:id` pattern.\n   * You can change this by passing an alternative regex from\n   * the result of this function.\n   */\n  paramMatcher?: (paramName: string) => RegExp;\n}\n\n/**\n * Use this function to create a single source of truth\n * for all routes in your app\n */\nexport const makeRouteMap = <R extends RoutesType>(\n  routes: R,\n  options?: MakeRouteMapOptions\n): RoutesReturn<R> => {\n  let obj: Partial<RoutesReturn<R>> = {};\n  Object.entries(routes).forEach(([_key, { path }]) => {\n    const key: keyof R = _key;\n\n    const func: RoutesReturn<R>[typeof key] = (routeInfo?: {\n      params?: {\n        [paramName: string]: string | number;\n      };\n      search?: {\n        [paramName: string]: string | number | undefined;\n      };\n    }) => {\n      let newPath = String(path);\n      // If params, add the new path to the object\n      if (routeInfo?.params) {\n        Object.entries(routeInfo.params).forEach(([paramName, value]) => {\n          newPath = newPath.replace(\n            options?.paramMatcher?.(paramName) || new RegExp(':' + paramName),\n            String(value)\n          );\n        });\n      }\n      if (!routeInfo?.search) {\n        return newPath;\n      } else {\n        return `${newPath}?${new URLSearchParams(\n          routeInfo.search as any\n        ).toString()}`;\n      }\n    };\n\n    obj[key] = func;\n  });\n  return obj as RoutesReturn<R>;\n};\n\n/**\n * Creates a navigate function which you can use to\n * navigate type-safely between all routes in your app\n */\nexport const makeNavigate = <R extends RoutesType>(\n  routeMap: RoutesReturn<R>,\n  goToRoute: (route: string) => void\n): UseNavigateReturn<R> => {\n  const toReturn: Partial<UseNavigateReturn<R>> = {};\n  Object.keys(routeMap).forEach(_routeName => {\n    const routeName: keyof UseNavigateReturn<R> = _routeName;\n    toReturn[routeName] = (params: any) => {\n      goToRoute(routeMap[routeName](params));\n    };\n  });\n  return toReturn as UseNavigateReturn<R>;\n};\n\nexport default makeRouteMap;\n"],"names":["makeRouteMap","routes","options","obj","Object","entries","forEach","path","routeInfo","newPath","String","params","paramName","value","replace","paramMatcher","RegExp","search","URLSearchParams","toString","routeMap","goToRoute","toReturn","keys","_routeName","routeName"],"mappings":"wEAwCaA,EAAe,SAC1BC,EACAC,OAEIC,EAAgC,UACpCC,OAAOC,QAAQJ,GAAQK,SAAQ,gBAAUC,OAAAA,KA8BvCJ,QA3B0C,SAACK,OAQrCC,EAAUC,OAAOH,UAEjBC,MAAAA,SAAAA,EAAWG,SACbP,OAAOC,QAAQG,EAAUG,QAAQL,SAAQ,kBAAEM,OAAWC,OACpDJ,EAAUA,EAAQK,SAChBZ,MAAAA,aAAAA,EAASa,wCAATb,EAAwBU,KAAc,IAAII,OAAO,IAAMJ,GACvDF,OAAOG,QAIRL,MAAAA,SAAAA,EAAWS,QAGJR,MAAW,IAAIS,gBACvBV,EAAUS,QACVE,WAJKV,MAUNN,0CAOmB,SAC1BiB,EACAC,OAEMC,EAA0C,UAChDlB,OAAOmB,KAAKH,GAAUd,SAAQ,SAAAkB,OACtBC,EAAwCD,EAC9CF,EAASG,GAAa,SAACd,GACrBU,EAAUD,EAASK,GAAWd,QAG3BW"}